You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. A recipe can also be an ingredient for other recipes, i.e., ingredients[i] may contain a string that is in recipes.

You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.

Return a list of all the recipes that you can create. You may return the answer in any order.

Note that two recipes may contain each other in their ingredients.


Example 1:

Input: recipes = ["bread"], ingredients = [["yeast","flour"]], supplies = ["yeast","flour","corn"]
Output: ["bread"]
Explanation:
We can create "bread" since we have the ingredients "yeast" and "flour".




________________________________________________________________________________________________________________________________________________

Intuition & Thoughts: The idea here is to see that the recipes array and ingredient array seem incredible similar to an adjacency list. Think about it, Each node in recipes has vertices to nodes that it needs to
                      create said recipe. For example, to cook bread, we need yeast and flour, so our bread node would have a directional edge to both yeast and flour.

                      This directional aspect helps us eliminate a potential approach, Union Find. Union Find is most effective on nondirectional graphs. Since this graph clearly has a directional, tree-like
                      relationship, we must use an algorithm closer to a Topological Sort (ie. BFS or DFS). Think about it, if we have [bread, sandwich] as our recipes, we obviously want to see if making bread is
                      possible first because bread is included in the ingredients of sandwich. However, we are not guaranteed that bread will be processed first. What if we are given [sandwich, bread] as our recipe
                      list? A naive solution would say that we cannot make a sandwich because we have not made bread yet, but it is indeed possible to make bread.

                      Rather than backtracking, we take a recursive approach. For a sandwich for example, we check its ingredients against a can_cook hashmap. The can_cook hashmap by default only has the supplies
                      set to True as we start with them. Lets say we need [bread,meat] for a sandwich and meat is given in the supplies array. In this case, we do not need to perform any actions at it is already
                      set to True in can_cook. However, for bread, we will notices that it is not declared in can_cook. We have not considered if we can make it or not. Again the naive solution would just say no,
                      but instead we are going to use DFS recursion and now check the ingredients of bread. If we have yeast and flour, we can return True for bread which will then bubble up and return True for 
                      sand which as we now have both meat (from the supplies) and sandwich (derived from DFS). 

                      Essentially, for each recipe, we are checking that all of the recipes ingredients can be derived from those base supplies. If they cannot, than any recipe including that underivable ingredient
                      will also be underivable.

________________________________________________________________________________________________________________________________________________

Implementation:

          class Solution:
              def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
          
                  # Dictionary comprehension to create recipe: ingredient pairs for easy access to neighbors (adjacency list)
                  recipe_index = {recipes[i]: i for i in range(len(recipes))}

                  # A can_cook dictionary that holds True or False. We need this boolean to avoid cycles, and therefore cannot use a set
                  can_cook={s:True for s in supplies}
          
                  # DFS function
                  def dfs(r):

                      # If we have ALREADY decided if this is cookable, return what value we have stored
                      if r in can_cook: 
                          return can_cook[r]
                      
                      # If this was not in our can_cook map, and is not in our recipes to be considered, it is impossible to ever get. Edge Case.
                      if r not in recipe_index:
                              return False
          
                      # Avoid Cyclical dependencies by setting the cookability of the current value to False before checking neighbors
                      can_cook[r] = False
          
                      # Check to see if ALL neighbors are derivable (use our adjacency list for access to neighbors)
                      for neighbor in ingredients[recipe_index[r]]:
          
                          # If at any point a neighbor (or other descendent) is not derivable, false should cascade up
                          if not dfs(neighbor):
                              can_cook[r] = False
                              return False
                      
                      # If all neighbors are derivable, we can cook this recipe 
                      can_cook[r] = True
                      return True
                  
                  # Return all recipes r that are derivable via dfs(r)
                  return [r for r in recipes if dfs(r)]
